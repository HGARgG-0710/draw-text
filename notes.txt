1. IDEA: re-do the thing in React? 
	There's a lot of same 'types' (kinds/classes) of elements repeating throughout the HTMl of the page. 
	Starts to bugger oneself a little bit. React-based refactoring could remedy it.

2. IDEA: create means to program curves ... (?using functions/Infinite series? some recursive name-giving mini-language?); 
	Consider how to factor them into the syntax... (?use '-' instead of '->' for them?);

	ABOUT CIRCLES: 

		More general - replace them with ellipses. 
		Input shape: 

			(startX, startY)-(angle, ?startAngle, ?endAngle, ?rotation)(endX, endY)
		
		1. 'angle' - angle between the point that is to be the center of the future ellipse and '(startX, startY)'. 
			Together with the end coordinate, sufficient to find the required data to draw the ellipse on the path using 'ellipse'; 
		2.-4. (rotation, startAngle, endAngle) are the same as in 'ellipse' documentation of Canvas

		By default, first argument is 'startAngle', 'rotation' is 0 and 'endAngle' is 2*pi ('startAngle' is 0 too so as to make a full ellipse...);

		
	ALSO - additional functionality: 

		1. Bezier curves (quadraticCurveTo and bezierCurveTo do a quadratic and cubic one correspondently, see if others are feasible to either implement using it or manually...); 
		2. roundRect (for pretty things and UI...);
		3. strokeText [add text to draw-text...]; 
		4. setLineDash (for dotted lines)
		5. fillText;
		6. drawImage (images!!! - implement together with the paths, arguments variables and file-running instead of necessarily getting the text from 'textarea' field);
		7. createPattern (return type - a 'colour');

		These ones are same as 'background' - they're 'properties'; 
		Can be set multiple times throughout...; 
		8 [ASAP!!!]. lineWidth ('width' property)
		9 [asap, too]. rounding of the lines - in particular, WITH A DESIRED ACCURACY! ('line-radius' property)

		10. A transparency argument...; 
		11. lineJoin - as a post-point 'specifier'; One of the following: 

			1. r - for rounded corners; 
			2. b - for bevel corners; 
			The miter corners are the default, so for them - no specifier...; 

		12. miterLimit ('limit' property)
		13. lineDashOffset ('dash-offset' property)
		14. gradients - conic, linear and radial (those that Canvas supports); 
		15. fill-rule (single-value property for setting fill rules - 'evenodd' or 'nonzero');
		16. shadow (command for shadows; takes arguments' shape of '(offsetx, offsety) blur? color?')
		17. font (property; for doing text-stroking/fillling); 

		Whole separate, under question: 
		18. Animations? [more complex, doing will require finding a finite set of elementary operations equivalent in power to multi-layer structures such as 'for-loops' in the sense of determining the algorithms...];

3. IDEA: for README, draw something pretty! [in a minimalistic-cubistic-style? how about a Bloodborne hunter picture? Or one of one's characters?]
4. IDEA: add more details to the page's HTML and CSS; 
	Examples: images for a more 'sophisticated' layout, gradient, multicolours, that kind of thing...;
5. CSS is good (adaptive for SOME screens..., computer screens for instance...), but not good enough for the app to be easily (comfortably) used on mobile devices...;
	For them - choose different proportions. 
	The values of phones are FARRR too different. 
	They are not height-oriented, but rather width-oriented...; 
6. ?Add more canvas programmatic properties to the project? 
	Ideally, the final thing ought to be something of a total-Canvas-drawing-API-wrapper, 
		but reformulated purely in terms of shapes (that being, 
			the entire programming paraphanalia is taken out - only these elementary instructions remain). 
7. IDEA: add 'comment's into the project's language's vocabulary...; 
	Useful for designation of particular elements of images, in the cases of certain complexity. 
8. IDEA [visual design]: add a generation of random pattern to the sides of the page (current blue-rect); 
	Think whether the pattern would be recurring, or it would create new colours each time user would 
		change the canvas size (thus increasing the page size...); 
	Also - consider how they'd be generated (that is, how would the colour pattern be chosen...
		What vector-function of n>=2 colour components - RGB/other - to pick/construct?)
	
9. Idea: add support for a 'point'-datatype to the parser; 

	Allows one to store (in variables) individual points instead of simply x/y/color coordinates of a point...;

10. A website Favicon - add it; 

	Think of something pretty. Draw it with 'draw-text'; 
	Then, use as a favicon (an .svg...); 

11. Arithmetic! 

	Add arithmetic for those expressions (simple addition, multiplication, division, subtraction and modulo ought to do it by now...); 
	Add simple case static/strong typezation typezation 
		(or, more precisely, add another layer of correctness-checking - now the program would also have to be sound from type-standpoint of view, 
			besides only just adequate parsibility); 
	Also - when implementing, add the rationals (at least the finite ones) and additive inverses support (in particular - for angles). 

12. Add input from file (giving a file with 'draw-text' code...);

	In particular - add the predefined 'arguments' variables, that can be accessed. 
	This way, one could run draw-text files/code with given arguments;

	[useful with images];

13. Add filereading: 

	For text files only (getting stroke-Text strings, colours, numbers and points); 

14. Add "string" type: 

	Easier to parse this way. Would be used for textual information; 

15. Add a simple 'compiler' program for draw-this code: 

	Would, in truth, simply substitute the argument-variables for static values, provided by the user; 
	Eliminates the need for further user input;

	Also - eliminates inner calls from other files 
		(if they are available - puts the code inside with appropriate name collisions in vars fixed (when required), otherwise - a compiler error); 
	
16. Add file-running: 

	Two directives: 

		1. run filepath [...arguments] - runs a given file within the context of the present canvas (without merging variable spaces); 
		2. paste filepath [...arguments] - pastes the code of the given file into the present one (note: IT DOES NOT HAVE TO BE CORRECT AS OF SELF, variables can be undefined, for instance);

17. Add a way to access the command-properties (such as 'radius'): 

	For instance, add a special symbol (like % or $, or @, or !) to get their values [those will be ignored by the 'validate' function]; 